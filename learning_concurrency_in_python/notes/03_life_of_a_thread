-----------------------------------------------------------------------
| CHAPTER 3 - LIFE OF A THREAD                                        |
-----------------------------------------------------------------------

- Threads in Python

    - Here is the definition of the 'Thread' class constructor:

        # Python Thread class constructor
        def __init__(self, group=None,
                           target=None,
                           name=None,
                           args=(),
                           kwargs=None,
                           verbose=None):


        group: This is a special parameter which is reserved for a future extension.

        target: This is the callable object to be invoked by the 'run()' method. If not passed, this will 
                  default to None, and nothing will be started.

        name: This is the thread name.

        args: This is the argument tuple for target invocation. It defaults to ().

        kwargs: This is a dictionary of keyword arguments to invoke the base class constructor.



- Thread States

    1. New = Thread hasn't started yet, and hasn't been allocated resources.

    2. Runnable = Waiting for scheduler, has all resources it needs to proceed.

    3. Running = Thread is executing.

    4. Not Running = Thread has been paused in some way, possibly to wait for I/O.

    5. Dead = Killed intentionally or not.



- Example - Thread States

    - Here, we'll look at the various states our theads can be in:

        import threading
        import time

        # Simple method for thread to execute
        def thread_worker():
            print('My thread has entered the Running state.')
            time.sleep(10)
            print('My thread is terminating.')

        # Still no resources allocated after this
        my_thread = threading.Thread(target=thread_worker)

        # Allocate resource and make thread runnable
        my_thread.start()



- Ways to Start a Thread

    - We can run a thread with a single function if we have some simple logic.  This is shown
        in 'starting_threads.py' in the 'start_function_threads' function.


    - If we have more complex logic, we can inherit from the Thread class.  This is shown in the
        'start_class_threads' function.  


    - We can use 'forking' to create a replica of a process.  When created, this new clone receives
        it's own PID independent of the parent process.

      For example, Apache does this to spawn off new processes, each of which has it's own address 
        space and can process it's own requests.  This way if a process crashes or dies, other
        processes running concurrently will be unaffected.

      This approach is shown in the 'parent' and 'child' functions.


    - We may have a need to start 'daemon threads', which have no endpoint.  They will run forever
        until your program quits.

      For example, you have a load balancer, and your service registry needs to know if each instance
        is still up, so each instance sends a heartbeat message to the service registry.  We could
        migrate this task to a daemon thread.



- Handling Threads in Python

    - Starting Lots of Threads

    - Slowing Down Programs Using Threads

    - Getting the Total Number of Active Threads

    - Getting the Current Thread

    - Main Thread

    - Enumerating All Threads

    - Identifying Threads

    - Ending a Thread



- How the OS Handles Threads



- Multithreading Models

    - One-to-One Thread Mapping

    - Many-to-One

    - Many-to-Many